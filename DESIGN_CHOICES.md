# DESIGN CHOICES
## Passing the Api key and Api secret with all the requests
In order to be able to interact with Testnet Bitmex api, one needs to create an account there and have an apiKey and apiSecret generated in a way that will provide him with the appropriate rights. 

In an ideal situation, if this BitmexIntegrationService was part of a larger platform, then the `apiKey` and `apiSecret` of every user which would interact with our service would be persisted in a secret server (AWS secret server for eg), and, upon receiving a request from an authenticated user, our application would just go and fetch the appropriate keys from the secret server and use them. This would be the best design from a security point of view. I did not have all that framework as part of this work, so I have opted for a less secure design: to have the `apiKey` and `apiSecret` as part of any request made to this `BitmexIntegrationService`; this way, every person who has an account on Testnet BITMEX will be able to use the service with his own account.

## Getting balances and reservedFunds
I made four specific choices in designing the endpoint `/bitmex/getWallets`:
1. Given that the text of this assignment mentioned that we want to get the wallets for all currencies, I have in the api of this service, restricted the choice given by the Bitmex testnet API. I don't offer the possibility to specify which wallet he wants to use to the user and always send him back the information for all the currencies when he makes a request to `/bitmex/getwallets`.
2. It had been suggested, based on the data given back by the Testnet api to use the formula : `balance = amount + pendingCredit + pendingDebit` when computing the balance of a wallet and the formula `reservedFund = pendingCredit + pendingDebit` when computing the reserved funds, but when further inspecting the data sent back by the testnet api, it seemed to me that `balance = amount + pendingCredit` made more sense as a formula to compute the balance, since `amount` already contains `pendingDebit`, so it is this last formula that I have used.
3. Since we were mostly interestsed in the balance and reservedfund, I don't send back to the user most of the wallet-related data which is sent back by testnet API. Although, in the framework of this test, it won't be an issue, in practice, this would help save DB space and avoid using the too much traffic for data we don't really need.
4. For the persistence, I have chosen to use an H2 in-memory db as this seemed the most pragmatic choice in our case, but, obviously, in a production context, we would use a db which is persisted on disc.